---
import RecipeCardCarousel from './RecipeCardCarousel.astro';
import { getLocale } from '../../i18n/i18n';

// Import all recipe files dynamically (use static glob and filter by lang)
const currentLang = getLocale();

interface Recipe {
  id: string;
  title: string;
  image: string;
  hover_image?: string;
  preparation_time: number;
  category?: string;
  category_en?: string;
  categories?: string[];
  categories_en?: string[];
  difficulty?: string;
  servings?: number;
  rating?: number;
}

// Define a type for the imported module
interface RecipeModule {
  default: Recipe;
}

// Optional items can be passed from parent (e.g., related recipes)
export interface Props {
  title?: string;
  textButton?: string;
  items?: Recipe[];
}

const {
  textButton = currentLang === 'es' ? 'Ver Todas' : 'View All',
  items
} = Astro.props;

// If items provided, use them; otherwise load all by lang
let recipeItems: Recipe[] = Array.isArray(items) ? items : [];
if (!recipeItems.length) {
  const recipeModules = import.meta.glob<RecipeModule>("../../locales/*/recipes/*.json");
  for (const path in recipeModules) {
    const lang = path.split('/')[3];
    if (lang === currentLang) {
      const mod = await recipeModules[path]();
      recipeItems.push(mod.default);
    }
  }
}

// Determine if we are in provided-items mode (hide filters/CTA)
const providedMode = Array.isArray(items) && items.length > 0;

// Normalizar categoría (usando claves en inglés para el filtrado)
function getCategoryKey(recipe: Recipe): string {
  const raw = (
    recipe?.category_en ||
    recipe?.category ||
    (Array.isArray(recipe?.categories_en) ? recipe.categories_en[0] : undefined) ||
    (Array.isArray(recipe?.categories) ? recipe.categories[0] : undefined) ||
    ''
  );
  const key = String(raw || '').trim().toLowerCase();
  // mapear posibles variaciones a claves conocidas
  if (['breakfast', 'desayuno'].includes(key)) return 'breakfast';
  if (['brunch'].includes(key)) return 'brunch';
  if (['lunch', 'almuerzo'].includes(key)) return 'lunch';
  return key || 'other';
}

// Etiquetas por idioma (solo UI)
const filterLabels = currentLang === 'es'
  ? { breakfast: 'DESAYUNO', brunch: 'BRUNCH', lunch: 'ALMUERZO', all: 'TODO' }
  : { breakfast: 'BREAKFAST', brunch: 'BRUNCH', lunch: 'LUNCH', all: 'ALL' };

// Para desktop: mostrar 4 tarjetas por vista, avanzar de 1 en 1
// Para mobile: 1 por slide (agrupadas de a 1)
const mobileGroups: Recipe[][] = [];
for (let i = 0; i < recipeItems.length; i += 1) {
  mobileGroups.push([recipeItems[i]].filter(Boolean));
}
---

<div class="w-full" data-recipes-carousel>
  <div class="w-full px-4 ">
    <!-- Título alineado a la izquierda -->
    
    <!-- Seccion de recetas -->
    
    <!-- Botones de filtro -->
    {!providedMode && (
    <div class="flex gap-2.5 mb-8 px-4 md:px-0 justify-center" id="recipesFilters">
         <button type="button" data-filter="all" class="filter-btn flex py-2 px-2.5 justify-center items-center gap-2.5 flex-1 text-md md:text-xl rounded-full border border-brown bg-yellow font-bold text-brown hover:bg-yellow-400 transition-colors">
        {filterLabels.all}
      </button>
      <button type="button" data-filter="breakfast" class="filter-btn flex py-2 px-2.5 justify-center items-center gap-2.5 flex-1 text-md md:text-xl rounded-full border border-brown bg-yellow font-bold text-brown hover:bg-yellow-400 transition-colors">
        {filterLabels.breakfast}
      </button>
      <button type="button" data-filter="brunch" class="filter-btn flex py-2 px-2.5 justify-center items-center gap-2.5 flex-1 text-md md:text-xl rounded-full border border-brown bg-yellow font-bold text-brown hover:bg-yellow-400 transition-colors">
        {filterLabels.brunch}
      </button>
      <button type="button" data-filter="lunch" class="filter-btn flex py-2 px-2.5 justify-center items-center gap-2.5 flex-1 text-md md:text-xl rounded-full border border-brown bg-yellow font-bold text-brown hover:bg-yellow-400 transition-colors">
        {filterLabels.lunch}
      </button>
   
    </div>
    )}
     
    <!-- Carousel de recetas - MOBILE (1 por slide) - Solo visible en mobile -->
<div class="recipes-carousel-mobile relative md:hidden">
  <div class="recipes-carousel-container overflow-hidden w-full flex justify-center">
    <div class="recipes-carousel-track flex items-center gap-0 transition-transform duration-300" id="recipesTrackMobile" style="transform: translateX(0);">
      {mobileGroups.map((group, gIndex) => (
        <div class="recipe-slide-group flex-shrink-0 w-full flex justify-center items-center px-4 pb-8"> 
          {group.map((recipe: Recipe) => (
            <div class="recipe-slide flex justify-center" data-category={getCategoryKey(recipe)}>
              <RecipeCardCarousel
                image={recipe.image}
                hoverImage={recipe.hover_image || recipe.image}
                title={recipe.title}
                time={`${recipe.preparation_time}MIN`}
                id={recipe.id}
                difficulty={recipe.difficulty || '---'}
                servings={recipe.servings || 0}
                rating={recipe.rating || 0}
                isMainCard={false}
              />
            </div>
          ))}
        </div>
      ))}
    </div>
  </div>

      <!-- Controles de navegación mobile (flechas y puntos) -->
      <div class="flex justify-center items-center gap-4 mt-6">
        <button class="carousel-prev bg-white text-brown p-2 rounded-full shadow-lg z-10" aria-label="Anterior" id="prevBtnMobile">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
          </svg>
        </button>

        <div class="carousel-dots-mobile flex gap-2"></div>

        <button class="carousel-next bg-white text-brown p-2 rounded-full shadow-lg z-10" aria-label="Siguiente" id="nextBtnMobile">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
          </svg>
        </button>
      </div>
    </div>

    <!-- Carousel de recetas - DESKTOP - Solo visible en desktop -->
    <div class="recipes-carousel relative hidden md:block">
      <div class="recipes-carousel-container overflow-visible ">
        <div class="recipes-carousel-track flex items-start justify-center w-full gap-4 md:gap-6 transition-transform duration-300" id="recipesTrackDesktop" style="transform: translateX(0);">
          {recipeItems.map((recipe, index) => (
            <div class="recipe-slide flex-shrink-0 group-hover-container" data-index={index} data-category={getCategoryKey(recipe)}>
              <RecipeCardCarousel
                image={recipe.image}
                hoverImage={recipe.hover_image || recipe.image}
                title={recipe.title}
                time={`${recipe.preparation_time}MIN`}
                id={recipe.id}
                difficulty={recipe.difficulty || '---'}
                servings={recipe.servings || 0}
                rating={recipe.rating || 0}
                isMainCard={false}
              />
            </div>
          ))}
        </div>
      </div>
      
      <!-- Controles de navegación desktop (flechas y puntos en la parte inferior) -->
      <div class="flex justify-center items-center gap-4 mt-8">
        <!-- Flecha anterior -->
        <button class="carousel-prev bg-white text-brown p-2 rounded-full shadow-lg z-10" aria-label="Anterior" id="prevBtnDesktop">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
          </svg>
        </button>
        
        <!-- Puntos indicadores -->
        <div class="carousel-dots-desktop flex gap-2"></div>
        
        <!-- Flecha siguiente -->
        <button class="carousel-next bg-white text-brown p-2 rounded-full shadow-lg z-10" aria-label="Siguiente" id="nextBtnDesktop">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
          </svg>
        </button>
      </div>
    </div>
    
    <!-- Botón "Ver Todas" - oculto cuando se proveen items -->
    {!providedMode && (
    <div class="flex justify-center mt-6 w-full px-4 md:px-0">
      <a href={`/${currentLang === 'es' ? 'es/recetas' : 'en/recipes'}`} class="bg-yellow text-brown font-bold py-2 px-8 rounded-full hover:border-brown hover:border-2 hover:bg-brown hover:text-yellow transition-colors w-full md:w-auto text-center font-title text-2xl">
        {textButton}
      </a>
    </div>
    )}
  </div>
</div>

<script>
  function initRecipesCarousel(root: HTMLElement): void {
    if (!root || root.dataset.rcInitialized === 'true') return;
    root.dataset.rcInitialized = 'true';
    
    let currentFilter = 'all';
    let filterTimeout: number | undefined;

    const filtersContainer = root.querySelector('#recipesFilters');
    const filterButtons: HTMLElement[] = Array.from(filtersContainer?.querySelectorAll('.filter-btn') || []);

    let stopMobileAutoplay: () => void = () => {};
    let startMobileAutoplay: () => void = () => {};
    let stopDesktopAutoplay: () => void = () => {};
    let startDesktopAutoplay: () => void = () => {};

    setupMobileCarousel();
    setupDesktopCarousel();

    filterButtons.forEach((btn: HTMLElement) => {
      btn.addEventListener('click', () => {
        const filter = btn.getAttribute('data-filter') || 'all';
        currentFilter = filter;
        
        filterButtons.forEach(b => b.classList.remove('ring-2', 'ring-brown'));
        btn.classList.add('ring-2', 'ring-brown');
        
        stopMobileAutoplay();
        stopDesktopAutoplay();
        
        if (filterTimeout) {
          clearTimeout(filterTimeout);
        }
        
        filterTimeout = window.setTimeout(() => {
          startMobileAutoplay();
          startDesktopAutoplay();
          filterTimeout = undefined;
        }, 45000);
        
        applyFilterMobile();
        applyFilterDesktop();
      });
    });

    function setupMobileCarousel(): void {
      applyFilterMobile(true);
    }

    function applyFilterMobile(initial: boolean = false): void {
      const track = root.querySelector('#recipesTrackMobile') as HTMLElement | null;
      const prevBtn = root.querySelector('#prevBtnMobile') as HTMLElement | null;
      const nextBtn = root.querySelector('#nextBtnMobile') as HTMLElement | null;
      const dotsContainer = root.querySelector('.carousel-dots-mobile') as HTMLElement | null;

      if (!track || !prevBtn || !nextBtn || !dotsContainer) return;

      const allGroups = Array.from(track.querySelectorAll('.recipe-slide-group')) as HTMLElement[];
      
      allGroups.forEach((group: HTMLElement) => {
        const slide = group.querySelector('.recipe-slide') as HTMLElement | null;
        const cat = slide?.getAttribute('data-category') || '';
        const visible = (currentFilter === 'all') || (cat === currentFilter);
        group.style.display = visible ? '' : 'none';
      });

      const visibleGroups = allGroups.filter(g => g.style.display !== 'none');
      let currentGroup = 0;
      let autoplayInterval: number | undefined;

      const prevClone = prevBtn.cloneNode(true) as HTMLElement;
      const nextClone = nextBtn.cloneNode(true) as HTMLElement;
      prevBtn.parentNode?.replaceChild(prevClone, prevBtn);
      nextBtn.parentNode?.replaceChild(nextClone, nextBtn);

      createDots();
      updatePosition();
      
      if (!filterTimeout) {
        startAutoplay();
      }

      prevClone.addEventListener('click', () => {
        stopAutoplay();
        if (currentGroup > 0) {
          currentGroup--;
          updatePosition();
        }
        if (!filterTimeout) {
          startAutoplay();
        }
      });

      nextClone.addEventListener('click', () => {
        stopAutoplay();
        if (currentGroup < visibleGroups.length - 1) {
          currentGroup++;
          updatePosition();
        }
        if (!filterTimeout) {
          startAutoplay();
        }
      });

      function createDots(): void {
        if (!dotsContainer) return;
        dotsContainer.innerHTML = '';
        for (let i = 0; i < visibleGroups.length; i++) {
          const dot = document.createElement('button');
          dot.classList.add('w-3', 'h-3', 'rounded-full', i === currentGroup ? 'bg-white' : 'bg-gray-300');
          dot.addEventListener('click', () => {
            stopAutoplay();
            currentGroup = i;
            updatePosition();
            if (!filterTimeout) {
              startAutoplay();
            }
          });
          dotsContainer.appendChild(dot);
        }
      }

      function updatePosition(): void {
        if (!track || !dotsContainer) return;
        
        const targetGroup = visibleGroups[currentGroup];
        const originalIndex = allGroups.indexOf(targetGroup);
        const percent = Math.max(0, originalIndex) * 100;
        track.style.transform = `translateX(-${percent}%)`;

        const dots = dotsContainer.querySelectorAll('button');
        dots.forEach((dot, i) => {
          if (i === currentGroup) {
            dot.classList.remove('bg-gray-300');
            dot.classList.add('bg-white');
          } else {
            dot.classList.remove('bg-white');
            dot.classList.add('bg-gray-300');
          }
        });

        prevClone.classList.toggle('opacity-50', currentGroup === 0);
        nextClone.classList.toggle('opacity-50', currentGroup >= visibleGroups.length - 1);
      }

      function startAutoplay(): void {
        stopAutoplay();
        autoplayInterval = window.setInterval(() => {
          if (currentGroup < visibleGroups.length - 1) {
            currentGroup++;
          } else {
            currentGroup = 0;
          }
          updatePosition();
        }, 4000);
      }

      function stopAutoplay(): void {
        if (autoplayInterval) {
          clearInterval(autoplayInterval);
          autoplayInterval = undefined;
        }
      }

      stopMobileAutoplay = stopAutoplay;
      startMobileAutoplay = startAutoplay;

      track.addEventListener('mouseenter', stopAutoplay);
      track.addEventListener('mouseleave', () => {
        if (!filterTimeout) {
          startAutoplay();
        }
      });
      track.addEventListener('touchstart', stopAutoplay);
    }

    function setupDesktopCarousel(): void {
      applyFilterDesktop(true);
    }

    function applyFilterDesktop(initial: boolean = false): void {
      const track = root.querySelector('#recipesTrackDesktop') as HTMLElement | null;
      const prevBtn = root.querySelector('#prevBtnDesktop') as HTMLElement | null;
      const nextBtn = root.querySelector('#nextBtnDesktop') as HTMLElement | null;
      const dotsContainer = root.querySelector('.carousel-dots-desktop') as HTMLElement | null;

      if (!track || !prevBtn || !nextBtn || !dotsContainer) return;

      const allSlides = Array.from(track.querySelectorAll('.recipe-slide')) as HTMLElement[];
      
      allSlides.forEach((slide: HTMLElement) => {
        const cat = slide.getAttribute('data-category') || '';
        const visible = (currentFilter === 'all') || (cat === currentFilter);
        slide.style.display = visible ? 'block' : 'none';
      });

      const visibleSlides = allSlides.filter(s => s.style.display !== 'none');
      let currentSlide = 0;
      let autoplayInterval: number | undefined;

      const prevClone = prevBtn.cloneNode(true) as HTMLElement;
      const nextClone = nextBtn.cloneNode(true) as HTMLElement;
      prevBtn.parentNode?.replaceChild(prevClone, prevBtn);
      nextBtn.parentNode?.replaceChild(nextClone, nextBtn);

      updateDesktopCarousel();
      createDesktopDots();
      
      if (!filterTimeout) {
        startAutoplay();
      }

      prevClone.addEventListener('click', () => {
        stopAutoplay();
        if (currentSlide > 0) {
          currentSlide--;
          updateDesktopCarousel();
        }
        if (!filterTimeout) {
          startAutoplay();
        }
      });

      nextClone.addEventListener('click', () => {
        stopAutoplay();
        if (currentSlide < Math.max(0, visibleSlides.length - 4)) {
          currentSlide++;
          updateDesktopCarousel();
        }
        if (!filterTimeout) {
          startAutoplay();
        }
      });

      function createDesktopDots(): void {
        if (!dotsContainer) return;
        dotsContainer.innerHTML = '';
        const totalDots = Math.max(0, visibleSlides.length - 3);
        for (let i = 0; i < totalDots; i++) {
          const dot = document.createElement('button');
          dot.classList.add('w-3', 'h-3', 'rounded-full', i === currentSlide ? 'bg-white' : 'bg-gray-300');
          dot.addEventListener('click', () => {
            stopAutoplay();
            currentSlide = i;
            updateDesktopCarousel();
            if (!filterTimeout) {
              startAutoplay();
            }
          });
          dotsContainer.appendChild(dot);
        }
      }

      function updateDesktopCarousel(): void {
        if (!track || !dotsContainer) return;
        
        visibleSlides.forEach((slide: HTMLElement, index: number) => {
          let card = slide.querySelector('a') as HTMLElement | null;
          if (card) {
            slide.style.width = '310px';
            slide.style.transition = 'width 300ms ease';

            const anyOverlay = card.querySelector('.absolute.inset-0');
            if (anyOverlay) anyOverlay.remove();

            const newCard = card.cloneNode(true) as HTMLElement;
            card.parentNode?.replaceChild(newCard, card);
            card = newCard;
            
            card.className = 'block group relative transition-all duration-500 ease-in-out flex-shrink-0 w-[310px] h-[562px]';
            
            const cardContainer = card.querySelector('div') as HTMLElement | null;
            const imgContainer = cardContainer?.querySelector('div[class*="rounded-t-"]') as HTMLElement | null;
            const infoContainer = cardContainer?.querySelector('div[class*="bg-[#F8E31F]"]') as HTMLElement | null;
            const title = card.querySelector('h3') as HTMLElement | null;
            const imgTag = imgContainer?.querySelector('img') as HTMLImageElement | null;

            if (cardContainer) cardContainer.style.width = '310px';
            if (cardContainer) cardContainer.style.height = '562px';
            if (imgContainer) imgContainer.style.width = '310px';
            if (imgContainer) imgContainer.style.height = '300px';
            if (infoContainer) infoContainer.style.width = '310px';
            if (infoContainer) infoContainer.style.height = '262px';
            if (title) title.className = 'font-title font-bold text-black leading-tight flex-1 flex items-center text-brown text-2xl';
            if (imgTag) imgTag.className = 'w-full h-full object-cover';

            card.addEventListener('mouseenter', () => {
              const baseW = 310;
              const bigW = 560;
              visibleSlides.forEach((s: HTMLElement) => {
                const c2 = s.querySelector('a') as HTMLElement | null;
                if (!c2) return;
                
                const cc2 = c2.querySelector('div') as HTMLElement | null;
                const imgC2 = cc2?.querySelector('div[class*="rounded-t-"]') as HTMLElement | null;
                const infoC2 = cc2?.querySelector('div[class*="bg-[#F8E31F]"]') as HTMLElement | null;
                const t2 = c2.querySelector('h3') as HTMLElement | null;
                
                if (c2 === card) {
                  s.style.width = `${bigW}px`;
                  c2.style.opacity = '1';
                  c2.style.zIndex = '10';
                  if (cc2) cc2.style.width = `${bigW}px`;
                  if (cc2) cc2.style.height = '562px';
                  if (imgC2) imgC2.style.width = `${bigW}px`;
                  if (imgC2) imgC2.style.height = '300px';
                  if (infoC2) infoC2.style.width = `${bigW}px`;
                  if (infoC2) infoC2.style.height = '262px';
                  if (t2) t2.className = 'font-sans font-bold text-black leading-tight flex-1 flex items-center text-2xl';
                } else {
                  s.style.width = `${baseW}px`;
                  c2.style.opacity = '0.35';
                  c2.style.zIndex = '1';
                  if (cc2) cc2.style.width = `${baseW}px`;
                  if (cc2) cc2.style.height = '562px';
                  if (imgC2) imgC2.style.width = `${baseW}px`;
                  if (imgC2) imgC2.style.height = '300px';
                  if (infoC2) infoC2.style.width = `${baseW}px`;
                  if (infoC2) infoC2.style.height = '262px';
                  if (t2) t2.className = 'font-sans font-bold text-black leading-tight flex-1 flex items-center text-lg';
                }
              });
            });

            card.addEventListener('mouseleave', () => {
              const baseW = 310;
              visibleSlides.forEach((s: HTMLElement) => {
                const c2 = s.querySelector('a') as HTMLElement | null;
                if (!c2) return;
                
                const cc2 = c2.querySelector('div') as HTMLElement | null;
                const imgC2 = cc2?.querySelector('div[class*="rounded-t-"]') as HTMLElement | null;
                const infoC2 = cc2?.querySelector('div[class*="bg-[#F8E31F]"]') as HTMLElement | null;
                const t2 = c2.querySelector('h3') as HTMLElement | null;
                
                s.style.width = `${baseW}px`;
                c2.style.opacity = '1';
                c2.style.zIndex = '';
                if (cc2) cc2.style.width = `${baseW}px`;
                if (cc2) cc2.style.height = '562px';
                if (imgC2) imgC2.style.width = `${baseW}px`;
                if (imgC2) imgC2.style.height = '300px';
                if (infoC2) infoC2.style.width = `${baseW}px`;
                if (infoC2) infoC2.style.height = '262px';
                if (t2) t2.className = 'font-sans font-bold text-black leading-tight flex-1 flex items-center text-lg';
              });
            });
          }

          if (index >= currentSlide && index < currentSlide + 4) {
            slide.style.display = 'block';
          } else {
            slide.style.display = 'none';
          }
        });
        
        const dots = dotsContainer.querySelectorAll('button');
        dots.forEach((dot, i) => {
          if (i === currentSlide) {
            dot.classList.remove('bg-gray-300');
            dot.classList.add('bg-white');
          } else {
            dot.classList.remove('bg-white');
            dot.classList.add('bg-gray-300');
          }
        });

        prevClone.classList.toggle('opacity-50', currentSlide === 0);
        nextClone.classList.toggle('opacity-50', currentSlide >= Math.max(0, visibleSlides.length - 4));
      }

      function startAutoplay(): void {
        stopAutoplay();
        autoplayInterval = window.setInterval(() => {
          const maxSlide = Math.max(0, visibleSlides.length - 4);
          if (currentSlide < maxSlide) {
            currentSlide++;
          } else {
            currentSlide = 0;
          }
          updateDesktopCarousel();
        }, 4000);
      }

      function stopAutoplay(): void {
        if (autoplayInterval) {
          clearInterval(autoplayInterval);
          autoplayInterval = undefined;
        }
      }

      stopDesktopAutoplay = stopAutoplay;
      startDesktopAutoplay = startAutoplay;

      track.addEventListener('mouseenter', stopAutoplay);
      track.addEventListener('mouseleave', () => {
        if (!filterTimeout) {
          startAutoplay();
        }
      });
    }
  }

  function initAll(): void {
    document.querySelectorAll('[data-recipes-carousel]')
      .forEach((el) => initRecipesCarousel(el as HTMLElement));
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initAll);
  } else {
    initAll();
  }
  document.addEventListener('astro:page-load', initAll);
  document.addEventListener('astro:after-swap', initAll);
</script>